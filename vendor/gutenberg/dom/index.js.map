{"version":3,"sources":["webpack://wp/webpack/bootstrap","webpack://wp/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://wp/@wordpress/dom/src/dom.js","webpack://wp/@wordpress/dom/src/focusable.js","webpack://wp/@wordpress/dom/src/index.js","webpack://wp/@wordpress/dom/src/tabbable.js","webpack://wp/external {\"this\":\"lodash\"}"],"names":["window","getComputedStyle","Node","TEXT_NODE","ELEMENT_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","isEdge","container","isReverse","onlyVertical","includes","tagName","selectionStart","selectionEnd","value","length","isContentEditable","getSelection","rangeCount","range","getRangeAt","cloneRange","isForward","isCollapsed","collapse","rangeRect","getRectangleFromRange","computedStyle","lineHeight","parseInt","height","padding","buffer","containerRect","getBoundingClientRect","verticalEdge","top","bottom","direction","isReverseDir","x","left","right","y","testRange","hiddenCaretRangeFromPoint","document","side","testRect","Math","abs","isHorizontalEdge","isVerticalEdge","collapsed","startContainer","nodeName","parentNode","index","Array","from","childNodes","indexOf","createRange","setStart","setEnd","rect","getClientRects","padNode","createTextNode","insertNode","removeChild","computeCaretRect","placeCaretAtHorizontalEdge","focus","rangeTarget","selectNodeContents","removeAllRanges","addRange","caretRangeFromPoint","doc","caretPositionFromPoint","point","offsetNode","offset","originalZIndex","style","zIndex","originalPosition","placeCaretAtVerticalEdge","mayUseScroll","editableRect","contains","scrollIntoView","isTextField","element","contentEditable","error","documentHasSelection","activeElement","isEntirelySelected","endContainer","startOffset","endOffset","lastChild","lastChildContentLength","nodeType","data","firstChild","getScrollContainer","node","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","replaceTag","ownerDocument","createElement","appendChild","replaceChild","wrap","SELECTOR","join","isVisible","offsetWidth","offsetHeight","isValidFocusableArea","map","closest","img","querySelector","name","find","context","elements","querySelectorAll","filter","focusable","tabbable","getTabIndex","tabIndex","getAttribute","isTabbableIndex","createStatefulCollapseRadioGroup","CHOSEN_RADIO_BY_NAME","collapseRadioGroup","result","type","checked","concat","hasChosen","hasOwnProperty","isChosen","hadChosenElement","without","mapElementToObjectTabbable","mapObjectTabbableToElement","object","compareObjectTabbables","a","b","aTabIndex","bTabIndex","findFocusable","sort","reduce"],"mappings":"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","file":"./build/dom/index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./packages/dom/build-module/index.js\");\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Browser dependencies\n */\n\nconst { getComputedStyle } = window;\nconst {\n\tTEXT_NODE,\n\tELEMENT_NODE,\n\tDOCUMENT_POSITION_PRECEDING,\n\tDOCUMENT_POSITION_FOLLOWING,\n} = window.Node;\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst {\n\t\tanchorNode,\n\t\tfocusNode,\n\t\tanchorOffset,\n\t\tfocusOffset,\n\t} = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container    Focusable element.\n * @param {boolean} isReverse    Set to true to check left, false to check right.\n * @param {boolean} onlyVertical Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nfunction isEdge( container, isReverse, onlyVertical ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\n\tif ( ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 ).cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\trange.collapse( ! isForward );\n\t}\n\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\tconst computedStyle = window.getComputedStyle( container );\n\tconst lineHeight = parseInt( computedStyle.lineHeight, 10 ) || 0;\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge.\n\tif (\n\t\t! isCollapsed &&\n\t\trangeRect.height > lineHeight &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\tconst padding = parseInt( computedStyle[\n\t\t`padding${ isReverse ? 'Top' : 'Bottom' }`\n\t], 10 ) || 0;\n\n\t// Calculate a buffer that is half the line height. In some browsers, the\n\t// selection rectangle may not fill the entire height of the line, so we add\n\t// 3/4 the line height to the selection rectangle to ensure that it is well\n\t// over its line boundary.\n\tconst buffer = 3 * parseInt( lineHeight, 10 ) / 4;\n\tconst containerRect = container.getBoundingClientRect();\n\tconst verticalEdge = isReverse ?\n\t\tcontainerRect.top + padding > rangeRect.top - buffer :\n\t\tcontainerRect.bottom - padding < rangeRect.bottom + buffer;\n\n\tif ( ! verticalEdge ) {\n\t\treturn false;\n\t}\n\n\tif ( onlyVertical ) {\n\t\treturn true;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst { direction } = computedStyle;\n\tconst isReverseDir = direction === 'rtl' ? ( ! isReverse ) : isReverse;\n\n\t// To calculate the horizontal position, we insert a test range and see if\n\t// this test range has the same horizontal position. This method proves to\n\t// be better than a DOM-based calculation, because it ignores empty text\n\t// nodes and a trailing line break element. In other words, we need to check\n\t// visual positioning, not DOM positioning.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + buffer : containerRect.bottom - buffer;\n\tconst testRange = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst side = isReverseDir ? 'left' : 'right';\n\tconst testRect = getRectangleFromRange( testRange );\n\n\t// Allow the position to be 1px off.\n\treturn Math.abs( testRect[ side ] - rangeRect[ side ] ) <= 1;\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tconst { startContainer } = range;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tconst index = Array.from( parentNode.childNodes ).indexOf( startContainer );\n\n\t\trange = document.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = document.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect() {\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = document.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc The document of the range.\n * @param {number}    x   Horizontal position within the current viewport.\n * @param {number}    y   Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tconst originalZIndex = container.style.zIndex;\n\tconst originalPosition = container.style.position;\n\n\t// A z-index only works if the element position is not static.\n\tcontainer.style.zIndex = '10000';\n\tcontainer.style.position = 'relative';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = originalZIndex;\n\tcontainer.style.position = originalPosition;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge( container, isReverse, rect, mayUseScroll = true ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse ? ( editableRect.bottom - buffer ) : ( editableRect.top + buffer );\n\n\tconst range = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif ( mayUseScroll && (\n\t\t\t( ! range || ! range.startContainer ) ||\n\t\t\t\t! range.startContainer.contains( container ) ) ) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\ttry {\n\t\tconst { nodeName, selectionStart, contentEditable } = element;\n\n\t\treturn (\n\t\t\t( nodeName === 'INPUT' && selectionStart !== null ) ||\n\t\t\t( nodeName === 'TEXTAREA' ) ||\n\t\t\tcontentEditable === 'true'\n\t\t);\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n\n/**\n * Check wether the current document has a selection.\n * This checks both for focus in an input field and general text selection.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection() {\n\tif ( isTextField( document.activeElement ) ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn element.selectionStart === 0 && element.value.length === element.selectionEnd;\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tconst lastChildContentLength = lastChild.nodeType === TEXT_NODE ?\n\t\tlastChild.data.length :\n\t\tlastChild.childNodes.length;\n\n\treturn (\n\t\tstartContainer === element.firstChild &&\n\t\tendContainer === element.lastChild &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === lastChildContentLength\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = window.getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport function wrap( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n","/**\n * References:\n *\n * Focusable:\n *  - https://www.w3.org/TR/html5/editing.html#focus-management\n *\n * Sequential focus navigation:\n *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n *\n * Disabled elements:\n *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements\n *\n * getClientRects algorithm (requiring layout box):\n *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface\n *\n * AREA elements associated with an IMG:\n *  - https://w3c.github.io/html/editing.html#data-model\n */\n\nconst SELECTOR = [\n\t'[tabindex]',\n\t'a[href]',\n\t'button:not([disabled])',\n\t'input:not([type=\"hidden\"]):not([disabled])',\n\t'select:not([disabled])',\n\t'textarea:not([disabled])',\n\t'iframe',\n\t'object',\n\t'embed',\n\t'area[href]',\n\t'[contenteditable]:not([contenteditable=false])',\n].join( ',' );\n\n/**\n * Returns true if the specified element is visible (i.e. neither display: none\n * nor visibility: hidden).\n *\n * @param {Element} element DOM element to test.\n *\n * @return {boolean} Whether element is visible.\n */\nfunction isVisible( element ) {\n\treturn (\n\t\telement.offsetWidth > 0 ||\n\t\telement.offsetHeight > 0 ||\n\t\telement.getClientRects().length > 0\n\t);\n}\n\n/**\n * Returns true if the specified area element is a valid focusable element, or\n * false otherwise. Area is only focusable if within a map where a named map\n * referenced by an image somewhere in the document.\n *\n * @param {Element} element DOM area element to test.\n *\n * @return {boolean} Whether area element is valid for focus.\n */\nfunction isValidFocusableArea( element ) {\n\tconst map = element.closest( 'map[name]' );\n\tif ( ! map ) {\n\t\treturn false;\n\t}\n\n\tconst img = document.querySelector( 'img[usemap=\"#' + map.name + '\"]' );\n\treturn !! img && isVisible( img );\n}\n\n/**\n * Returns all focusable elements within a given context.\n *\n * @param {Element} context Element in which to search.\n *\n * @return {Element[]} Focusable elements.\n */\nexport function find( context ) {\n\tconst elements = context.querySelectorAll( SELECTOR );\n\n\treturn [ ...elements ].filter( ( element ) => {\n\t\tif ( ! isVisible( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { nodeName } = element;\n\t\tif ( 'AREA' === nodeName ) {\n\t\t\treturn isValidFocusableArea( element );\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n","/**\n * Internal dependencies\n */\nimport * as focusable from './focusable';\nimport * as tabbable from './tabbable';\n\n/**\n * Object grouping `focusable` and `tabbable` utils\n * under the keys with the same name.\n */\nexport const focus = { focusable, tabbable };\n\nexport * from './dom';\n","/**\n * External dependencies\n */\nimport { without } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport { find as findFocusable } from './focusable';\n\n/**\n * Returns the tab index of the given element. In contrast with the tabIndex\n * property, this normalizes the default (0) to avoid browser inconsistencies,\n * operating under the assumption that this function is only ever called with a\n * focusable node.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\n *\n * @param {Element} element Element from which to retrieve.\n *\n * @return {?number} Tab index of element (default 0).\n */\nfunction getTabIndex( element ) {\n\tconst tabIndex = element.getAttribute( 'tabindex' );\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\n}\n\n/**\n * Returns true if the specified element is tabbable, or false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is tabbable.\n */\nexport function isTabbableIndex( element ) {\n\treturn getTabIndex( element ) !== -1;\n}\n\n/**\n * Returns a stateful reducer function which constructs a filtered array of\n * tabbable elements, where at most one radio input is selected for a given\n * name, giving priority to checked input, falling back to the first\n * encountered.\n *\n * @return {Function} Radio group collapse reducer.\n */\nfunction createStatefulCollapseRadioGroup() {\n\tconst CHOSEN_RADIO_BY_NAME = {};\n\n\treturn function collapseRadioGroup( result, element ) {\n\t\tconst { nodeName, type, checked, name } = element;\n\n\t\t// For all non-radio tabbables, construct to array by concatenating.\n\t\tif ( nodeName !== 'INPUT' || type !== 'radio' || ! name ) {\n\t\t\treturn result.concat( element );\n\t\t}\n\n\t\tconst hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty( name );\n\n\t\t// Omit by skipping concatenation if the radio element is not chosen.\n\t\tconst isChosen = checked || ! hasChosen;\n\t\tif ( ! isChosen ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// At this point, if there had been a chosen element, the current\n\t\t// element is checked and should take priority. Retroactively remove\n\t\t// the element which had previously been considered the chosen one.\n\t\tif ( hasChosen ) {\n\t\t\tconst hadChosenElement = CHOSEN_RADIO_BY_NAME[ name ];\n\t\t\tresult = without( result, hadChosenElement );\n\t\t}\n\n\t\tCHOSEN_RADIO_BY_NAME[ name ] = element;\n\n\t\treturn result.concat( element );\n\t};\n}\n\n/**\n * An array map callback, returning an object with the element value and its\n * array index location as properties. This is used to emulate a proper stable\n * sort where equal tabIndex should be left in order of their occurrence in the\n * document.\n *\n * @param {Element} element Element.\n * @param {number}  index   Array index of element.\n *\n * @return {Object} Mapped object with element, index.\n */\nfunction mapElementToObjectTabbable( element, index ) {\n\treturn { element, index };\n}\n\n/**\n * An array map callback, returning an element of the given mapped object's\n * element value.\n *\n * @param {Object} object Mapped object with index.\n *\n * @return {Element} Mapped object element.\n */\nfunction mapObjectTabbableToElement( object ) {\n\treturn object.element;\n}\n\n/**\n * A sort comparator function used in comparing two objects of mapped elements.\n *\n * @see mapElementToObjectTabbable\n *\n * @param {Object} a First object to compare.\n * @param {Object} b Second object to compare.\n *\n * @return {number} Comparator result.\n */\nfunction compareObjectTabbables( a, b ) {\n\tconst aTabIndex = getTabIndex( a.element );\n\tconst bTabIndex = getTabIndex( b.element );\n\n\tif ( aTabIndex === bTabIndex ) {\n\t\treturn a.index - b.index;\n\t}\n\n\treturn aTabIndex - bTabIndex;\n}\n\nexport function find( context ) {\n\treturn findFocusable( context )\n\t\t.filter( isTabbableIndex )\n\t\t.map( mapElementToObjectTabbable )\n\t\t.sort( compareObjectTabbables )\n\t\t.map( mapObjectTabbableToElement )\n\t\t.reduce( createStatefulCollapseRadioGroup(), [] );\n}\n","(function() { module.exports = this[\"lodash\"]; }());"],"sourceRoot":""}